// Generated by CoffeeScript 1.6.3
(function() {
  var Dictionary, define, defineFn, dict, fn,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Dictionary = require('./dictionary');

  fn = require('./fn');

  dict = new Dictionary();

  global.log = function(obj) {
    var key, value;
    console.log('\n{');
    for (key in obj) {
      value = obj[key];
      console.log("  " + key + ": " + (typeof value));
    }
    return console.log('}\n');
  };

  /*
   * Define
   *
   * Create a new type definition
   *
   * - name (string)
   * - type (string)
   * - options (object)
   *
   * - type (function)
   * - options (function)
  */


  define = function(name, type, options) {
    var def, key, keys, method, propType, proto, protoFn, protoFns, protoKeys, typeCheck, value, _ref;
    def = dict.add({
      name: name,
      type: type,
      options: options
    });
    if (typeof type === 'function') {
      return def.fn = type;
    }
    typeCheck = dict.get(type).fn;
    if (!options) {
      return def.fn = typeCheck;
    }
    if (typeof options === 'function') {
      return def.fn = fn.custom(typeCheck, options);
    }
    if (options.all) {
      propType = dict.get(options.all).fn;
      return def.fn = fn.single(typeCheck, propType);
    }
    keys = options.keys != null ? options.keys : options.keys = {};
    for (key in keys) {
      value = keys[key];
      keys[key] = dict.get(value).fn;
    }
    method = options.other ? 'flexible' : 'strict';
    switch (typeof options.inherit) {
      case 'undefined':
        return def.fn = fn[method](typeCheck, keys);
      case 'string':
        proto = dict.get(options.inherit);
        protoKeys = proto.options.keys;
        protoFn = proto.protoFn;
        keys.__proto__ = protoKeys;
        if (protoFn) {
          def.protoFn = protoFn;
          return def.fn = fn.inherit[method](typeCheck, keys, protoFn);
        } else {
          return def.fn = fn[method](typeCheck, keys);
        }
        break;
      case 'object':
        if (!options["switch"]) {
          throw new Error('Must specify switch fn if inherit is an object: ' + name);
        }
        protoFns = {};
        _ref = options.inherit;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          value = _ref[key];
          proto = dict.get(value);
          protoKeys = proto.options.keys;
          protoFn = proto.protoFn;
          if (protoFn) {
            protoFns[key] = fn.setProtoChain(keys, protoKeys, protoFn);
          } else {
            protoFns[key] = fn.setProto(keys, protoKeys);
          }
        }
        def.protoFn = fn.switchProto(protoFns, options["switch"]);
        return def.fn = fn.inherit[method](typeCheck, keys, def.protoFn);
    }
    throw new Error('Could not read options');
  };

  /*
   * Define Function
   *
   * - name (string)
   * - types... (string)
  */


  defineFn = function() {
    var args, name, type, types, _i, _len;
    name = arguments[0], types = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    args = [];
    for (_i = 0, _len = types.length; _i < _len; _i++) {
      type = types[_i];
      if (type[0] === '~') {
        fn = dict.get(type.slice(1)).fn;
        fn.optional = true;
      } else {
        fn = dict.get(type).fn;
      }
      args.push(fn);
    }
    return function() {
      var arg, i, input, _j, _len1;
      input = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (i = _j = 0, _len1 = args.length; _j < _len1; i = ++_j) {
        arg = args[i];
        if (input[i] === void 0 && arg.optional) {
          continue;
        }
        if (!arg(input[i])) {
          return false;
        }
      }
      return true;
    };
  };

  module.exports = {
    define: define,
    defineFn: defineFn,
    undefine: dict.remove
  };

  require('./defaults');

}).call(this);
